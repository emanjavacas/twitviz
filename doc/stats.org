
* Namespace declaration and utils functions
#+BEGIN_SRC clojure :results silent
(ns twitviz.stats
  (:require [my-utils.io :refer :all]
            [my-utils.syntax :refer :all]
	    [clojure.string :as s]
	    [clojure.data.json :as json]
            [clojure.data.csv :as csv]
            [incanter
             [core charts stats ]]
            ))
;             [datasets :refer :all]]))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(defn fetch-hoods [city]
  (let [cities {"berlin" "resources/hoods/berlin.geojson"
                "berlin-light" "resources/hoods/berlin.json"
                "amsterdam" "resources/hoods/amsterdam.geojson"
                "antwerp" "resources/hoods/antwerp.geojson"
                "brussels" "resources/hoods/bruxelles.geojson"}
        cityjson (json/read-json (slurp (get cities city)))]
    (map (fn [hood] {:meta (get-in hood [:properties :name]) 
                     :geometry (vec (for [[y x] (first (get-in hood [:geometry :coordinates]))]
                                      [x y]))})
         (:features cityjson))))

(defn load-grid [grid-fn]
  (let [grid (atom {})
        lines (lazy-lines grid-fn)
        w (parse-number (first lines))
        h (parse-number (second lines))
        pts (drop 2 lines)]
    (doseq [pt pts
            :let [[tile ls] (map s/trim (s/split pt #" \| "))
                  [lon lat] (map parse-number (s/split tile #" "))
                  ls-map (-> (apply hash-map (s/split ls #" "))                             
                             (map-kv parse-number))]]
      (swap! grid assoc [lon lat w h] ls-map))
    @grid))

(defn deep-map-to-dense
  "transforms a nested map representation
  into dense matrix form updating zeros"
  ([m] (let [ks (->> (vals m)
                 (mapcat keys)
                 (into #{}))]
     (deep-map-to-dense m ks)))
  ([m ks] (reduce-kv (fn [acc k v]
                (let [new-v (zipmap ks (map #(get v % 0) ks))]
                  (assoc-in acc [k] new-v)))
              {}
              m)))	      

(defn map-to-dense [m ks]
  (reduce (fn [acc k]
            (assoc acc k (get m k 0)))
          {}
          ks))
#+END_SRC


* Implementation of Theil multigroup entropy index

** Description of the measure

For a succint description see [[http://www.census.gov/hhes/www/housing/housing_patterns/multigroup_entropy.pdf][this]] from the census.gov website.
For a scientific reference and foundation of the metric see (Reardon & Firebaugh 2002 and M. White 1983)

The following formulae implement the Theil's multigroup entropy index as per the following equation.


\[
H = \sum\limits_{j=1}^J \frac{t_j}{TE}(E - E_j)
\]

where J is the number of organizational units (districts, cells, etc...), t_j is the total number of individuals
in organizational unit j, T is total number of organizational units, E is the total diversity and E_j is the
diversity observed in organizational unit j.

Since we are using Theil's entropy index, the measure for diversity (E) is computed with the following
information theoretical formula:

\[
E = \sum\limits_{m=1}^M \pi_m  ln (\frac{1}{\pi_m})
\]

where M is the total number of groups in the population (in our case it amounts to languages) and \pi is the proportion
of group m in the population (note that normally the natural log is taken).

Note to myself, in NLP, entropy is normally shown as 
\[
E = -\sum\limits_{m=1}^M \pi_m  ln (\pi_m)
\]

In Reardon & Firebaugh 2002 (pg. 44ff), this entropy-based multigroup segregation index is derived as diversity ratio.
First, a measure of the "diversity" is defined (in our case entropy) and, then, segregation is defined as
the share of this diversity accounted for by the differences in group proportions across units.

The diversity measure is assumed to be defined as a function of the population shares of each of the groups
and it should acquire its minimum value of zero where all individuals are members of the same group
and its maximum value when each group is equally represented in the population. Which certainly holds for entropy.

Given a diversity measure d, a population of M groups, with a total of T individuals distributed
across T organizational units, it can be shown that if d is continous, differentiable and cooncave-down, then
\[
0 \leq \sum\limits_{j=1}^J \frac{t_j}{T} d_j \geq d
\]

which means that the weighted average of of the within-unit diversities will
always be greater than or equal to zero, with equality holding if each unit has no diversity,
and less than or equal total diversity, with equality holding when all within-unit proportions are
equal to the global group proportions.

Taking advantage of this fact, one can state a global segregation measure
\[
S(d) = 1 - \frac{\bar{d_j}}{d} = \sum\limits_{j=1}^J \frac{t_j}{Td} (d - dj)
\]

which equals the first equation when d is E.

** Properties
Theil's multigroup diversity index is bounded by zero and one.

** Implementation

#+BEGIN_SRC clojure :results silent
(defn entropy-score
  "computes total entropy for a distribution of counts"
  [ps]
  (reduce + (map (fn [p] (* p (Math/log (/ 1 p)))) ps)))
  
(defn gs->ps
  "normalizes by total count"
  ([gs] (gs->ps gs (reduce + gs)))
  ([gs total]
   (map #(/ % total) gs)))

(defn entropy-index
  "computes theil's entropy index for a collection
  of distribution of counts"
  [gms]
  (let [T (reduce + (mapcat vals gms))
        E (entropy-score (gs->ps (mapcat vals gms) T))
        ET (* E T)]
    (reduce + (map (fn [m]
                     (let [t (reduce + (vals m))
                           e (entropy-score (gs->ps (vals m) t))]
                       (/ (* t (- E e))
                          ET)))
                   gms))))
#+END_SRC


* Computations
** Based on tweets

- Fetch the data
 #+BEGIN_SRC clojure :results silent
(def data-dir "/Users/quique/data/twitproj/")
(def in-dir "/Users/quique/code/clojure/twitviz/")
(def berlin (load-grid (str in-dir "resources/files/berlin.grid")))
(def berlin-hoods (fetch-hoods "berlin"))
(def berlin-hoods-light (fetch-hoods "berlin-light"))
(def berlin-by-hood (frm-load (str data-dir "berlin_by_hoods_light.tweets")))
 #+END_SRC

#+BEGIN_SRC clojure

#+END_SRC

#+RESULTS:

- The distribution of cells by district is then
#+BEGIN_SRC clojure :results value
(map #(count (vals (second %))) berlin-by-hood)
#+END_SRC

#+RESULTS:
| 440 | 453 | 439 | 480 | 553 | 488 | 348 | 242 | 280 | 451 | 473 | 355 |

1) The total number of points in which the computation is based.
#+BEGIN_SRC clojure
(reduce + (mapcat vals (mapcat vals (vals berlin-by-hood))))
#+END_SRC

#+RESULTS:
: 270043

- Compute entropies by neighbourhood
#+BEGIN_SRC clojure :results silent
(def result-tweets
  (zipmap (keys berlin-by-hood)
          (map entropy-index (map vals (vals berlin-by-hood)))))
#+END_SRC

** Based on register data

- Read in data
#+BEGIN_SRC clojure :results silent
(def berlin-register (frm-load (str data-dir "berlin_by_districts.register")))
#+END_SRC

*** Compute entropy (normalizing hood names)
#+BEGIN_SRC clojure :results silent
(def result-register (zipmap (map #(second (clojure.string/split % #" ")) (keys berlin-register))
                     (map entropy-index (map vals (vals berlin-register)))))
#+END_SRC


#+BEGIN_SRC clojure :results silent
(def result-merged (merge-with vector result-tweets result-register))
(def x (map first (vals result-merged)))
(def y (map second (vals result-merged)))
(clojure.pprint/pprint result-merged)
#+END_SRC

#+RESULTS:
#+begin_example
{"Charlottenburg-Wilmersdorf" [0.834134741933901  0.7398183167160721],
 "Spandau"                    [0.9084754000487446 0.7780782138734974],
 "Pankow"                     [0.8762883761933832 0.8380497077104752],
 "Mitte"                      [0.8269929167774379 0.6936442588657165],
 "Steglitz-Zehlendorf"        [0.9019247857002738 0.8028626412058488],
 "Reinickendorf"              [0.8803239786996437 0.7896145263556944],
 "Neukölln"                   [0.8500908792523975 0.7343981458784431],
 "Friedrichshain-Kreuzberg"   [0.8226599155950466 0.7116018131026864],
 "Lichtenberg"                [0.8914504298018489 0.8382789317832962],
 "Tempelhof-Schöneberg"       [0.8696219289667678 0.7569444211626952],
 "Treptow-Köpenick"           [0.913796737368426  0.8990007985980895],
 "Marzahn-Hellersdorf"        [0.9395921710538039 0.8818968964340289]}
#+end_example

*** Barplot
#+BEGIN_SRC clojure :results silent
(def barchart (bar-chart (mapcat identity (repeat 2 (keys result-merged)))
                 (concat (map first (vals result-merged)) (map second (vals result-merged)))
                 :group-by (concat (repeat 12 "Tweets") (repeat 12 "Register"))
		 :x-label "Districts" :y-label "Theil's entropy index"
                 :legend true))
(save barchart "barchart.png" :width 1000)
#+END_SRC

*** Scatterplot
#+BEGIN_SRC clojure
(def correlation-scatter (scatter-plot x y :x-label "Tweets" :y-label "Register data"))
(def lm (linear-model y x))
(add-lines correlation-scatter x (:fitted lm))
(save correlation-scatter "scatter_correlation.png")
(view correlation-scatter)
#+END_SRC

#+RESULTS:
: #'twitviz.stats/x#'twitviz.stats/y#'twitviz.stats/correlation-scatter#'twitviz.stats/lm#<JFreeChart org.jfree.chart.JFreeChart@5ac9fce>nil#<ChartFrame org.jfree.chart.ChartFrame[frame9,0,22,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,22,500x378,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777675,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]>

#+BEGIN_SRC clojure
(count (flatten (repeat 2 (keys result-merged))))
(count (mapcat (juxt first second) (vals result-merged)))
#+END_SRC
#+RESULTS:
: 2424

#+BEGIN_SRC clojure
(flatten (repeat 2 (keys result-merged)))
#+END_SRC

#+RESULTS:
| Charlottenburg-Wilmersdorf | Spandau | Pankow | Mitte | Steglitz-Zehlendorf | Reinickendorf | Neukölln | Friedrichshain-Kreuzberg | Lichtenberg | Tempelhof-Schöneberg | Treptow-Köpenick | Marzahn-Hellersdorf | Charlottenburg-Wilmersdorf | Spandau | Pankow | Mitte | Steglitz-Zehlendorf | Reinickendorf | Neukölln | Friedrichshain-Kreuzberg | Lichtenberg | Tempelhof-Schöneberg | Treptow-Köpenick | Marzahn-Hellersdorf |

*** Correlations
#+BEGIN_SRC clojure
(correlation x y)
#+END_SRC

#+RESULTS:
: 0.870187217188301

#+BEGIN_SRC R :results output
x <-c(0.834134741933901, 0.9084754000487446, 0.8762883761933832, 0.8269929167774379,
      0.9019247857002738, 0.8803239786996437, 0.8500908792523975, 0.8226599155950466,
      0.8914504298018489, 0.8696219289667678, 0.913796737368426, 0.9395921710538039)

y <- c(0.7398183167160721, 0.7780782138734974, 0.8380497077104752, 0.6936442588657165,
       0.8028626412058488, 0.7896145263556944, 0.7343981458784431, 0.7116018131026864,
       0.8382789317832962, 0.7569444211626952, 0.8990007985980895, 0.8818968964340289)

cor.test(x, y)
#+END_SRC

#+RESULTS:
#+begin_example

	Pearson's product-moment correlation

data:  x and y
t = 5.5848, df = 10, p-value = 0.0002325
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 0.5918632 0.9631099
sample estimates:
      cor 
0.8701872 

#+end_example

--- permutation test
#+BEGIN_SRC clojure
(def permuted-tweets (sample-permutations 5000 x))
(def permuted-register (sample-permutations 5000 y))
(def permuted-corrs (map correlation 
                         permuted-tweets
                         permuted-register))
#+END_SRC

#+BEGIN_SRC clojure
(view (histogram permuted-corrs))
#+END_SRC
#+RESULTS:
: #<ChartFrame org.jfree.chart.ChartFrame[frame10,0,22,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,22,500x378,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777675,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]>

#+BEGIN_SRC clojure
(mean permuted-corrs)
#+END_SRC

#+RESULTS:
: -0.00395862067519123

#+BEGIN_SRC clojure
(quantile permuted-corrs :probs [0.025 0.975])
#+END_SRC

#+RESULTS:
| -0.5958495220859663 | 0.5788970950038481 |


* Association measures (language-district)

- load the data  
#+BEGIN_SRC clojure :results silent
(def berlin-by-hood (frm-load (str data-dir "berlin_by_hoods_light.tweets")))
#+END_SRC

- langs 
#+BEGIN_SRC clojure
(def langs
  (->> (vals berlin-by-hood)
       (mapcat vals)
       (mapcat keys)
       (into #{})))
#+END_SRC

#+RESULTS:
: #'twitviz.stats/langs

#+BEGIN_SRC clojure
(count langs)
#+END_SRC

#+RESULTS:
: 41

- hoods
#+BEGIN_SRC clojure
(def hoods (keys berlin-by-hood))
#+END_SRC

#+RESULTS:
: #'twitviz.stats/hoods

- aggregate langs by neighbourhood
#+BEGIN_SRC clojure
(def langs-by-hood
  (reduce-kv (fn [acc k v]
               (let [counts (flatten (vals v))
                     new-v (apply merge-with + counts)]
                 (assoc-in acc [k] new-v)))
             {}
             berlin-by-hood))
#+END_SRC

#+RESULTS:
: #'twitviz.stats/langs-by-hood

# dataframe with district as class and counts by cell instead of district
#+BEGIN_SRC clojure
(def langs-by-hood-grid
  (into [] (for [[district grid] berlin-by-hood
                 [k ls] grid]
             [district (map-to-dense ls langs)])))
#+END_SRC

#+RESULTS:
: #'twitviz.stats/langs-by-hood-grid


#+BEGIN_SRC clojure
(map keys (vals langs-by-hood))
#+END_SRC

#+RESULTS:
| nl | pt | en | lv | cy | zh | ro | tr | it | el | fa | is | id | uk | pl | fi | ca | sv | sl | fr | kn | da | de | ru | sk | es | ja | cs | no | ar | bg | ko | th |    |    |    |    |    |    |
| nl | pt | en | lv | ur | ro | tr | it | fa | uk | pl | fi | ca | sv | hr | sl | fr | de | ru | es | ja | cs | ar | th |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | lt | ur | zh | tr | it | el | fa | vi | id | pl | fi | ca | sv | hr | sl | fr | da | hu | de | ru | es | ja | cs | no | ar | ko | th |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | lt | ur | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | zh | tr | it | el | id | pl | fi | ca | sv | sl | fr | da | hu | de | hi | ru | sk | es | ja | cs | ar | ko | th |    |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | ur | zh | ro | tr | it | el | fa | vi | id | uk | pl | fi | sv | fr | da | de | ru | es | ja | cs | no | ar | bg | ko | th |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | ur | tr | it | el | fa | id | pl | fi | ca | sv | sl | fr | da | de | hi | ru | es | ja | et | no | ar | ko |    |    |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | ur | cy | zh | ro | tr | it | el | fa | is | id | uk | pl | fi | ca | sv | sl | fr | da | hu | de | ru | sk | es | ja | et | cs | no | ar | ko | th |    |    |    |    |    |
| nl | pt | en | lv | tr | it | el | vi | id | pl | fi | ca | sv | fr | da | de | hi | ru | es | ja | no | ar | bg | ko |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | ur | zh | ro | tr | it | el | fa | id | pl | fi | ca | sv | fr | da | hu | de | hi | ru | es | ja | no | ar | bg | ko | th |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | tr | it | el | vi | uk | pl | fi | ca | sv | fr | da | hu | de | ru | es | ja | ar | th |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
| nl | pt | en | lv | ro | tr | it | id | uk | pl | sv | fr | de | ru | es | ja | cs | ar | ko |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |


#+BEGIN_SRC clojure
(map keys (vals (deep-map-to-dense langs-by-hood)))
#+END_SRC

#+RESULTS:
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |
| nl | pt | en | lv | lt | ur | cy | zh | ro | hy | tr | it | el | fa | is | vi | id | uk | pl | fi | ca | sv | hr | sl | fr | kn | da | hu | de | hi | ru | sk | es | ja | et | cs | no | ar | bg | ko | th |

### Not run
#+BEGIN_SRC clojure
(with-open [wrt (clojure.java.io/writer "test.json")]
  (json/write (deep-map-to-dense langs-by-hood) wrt :escape-unicode false)) 
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC clojure
(with-open [wrt (clojure.java.io/writer "test_grid.json")]
  (.write wrt (apply str (interpose "," (flatten ["district" (vec langs) "\n"]))))
  (doseq [[district m] langs-by-hood-grid]
    (.write wrt (apply str (interpose "," (flatten [district (map (partial get m) langs) "\n"]))))))
#+END_SRC

#+RESULTS:
: nil

** R analysis
 #+BEGIN_SRC R
library(RJSONIO)
data <- as.data.frame(fromJSON("~/code/clojure/twitviz/test.json"))
 #+END_SRC

 #+RESULTS:
 |  120 |    9 |    35 |   417 |   21 |   47 |   24 |   278 |   40 |   41 |   18 |    2 |
 |  896 |   36 |   219 |  2389 |   53 |   98 |  142 |  1493 |  233 |  949 |  118 |   15 |
 | 9556 |  960 | 10748 | 34541 | 1975 | 4354 | 3248 | 18063 | 1832 | 4652 | 1956 |  729 |
 |  111 |    8 |     4 |    42 |   17 |    0 |    1 |    34 |    6 |   13 |    0 |   14 |
 |    0 |    0 |     1 |     1 |    0 |    0 |    0 |     0 |    0 |    0 |    0 |    0 |
 |    0 |    1 |     3 |     4 |    0 |    1 |    3 |    13 |    0 |    1 |    0 |    0 |
 |    1 |    0 |     0 |     0 |    0 |    0 |    0 |     1 |    0 |    0 |    0 |    0 |
 |    1 |    0 |    15 |    16 |    1 |    1 |    0 |     5 |    0 |    1 |    0 |    0 |
 |    1 |    2 |     0 |     4 |    0 |    2 |    0 |     2 |    0 |    1 |    0 |    1 |
 |    0 |    0 |     0 |     1 |    0 |    0 |    0 |     0 |    0 |    0 |    0 |    0 |
 | 1077 |  611 |   115 |  2414 |  341 | 2580 | 3729 |  2603 |   28 | 1815 |  189 |  149 |
 |  317 |   29 |   247 |   898 |   61 |   79 |   65 |   485 |    6 |  395 |   17 |    6 |
 |  142 |    0 |     2 |   135 |    4 |    3 |   63 |    21 |   13 |    6 |   10 |    0 |
 |    4 |    2 |     1 |     9 |    0 |    1 |    2 |    10 |    0 |    2 |    0 |    0 |
 |    4 |    0 |     0 |    13 |    0 |    0 |    0 |     3 |    0 |    0 |    0 |    0 |
 |    0 |    0 |    51 |     6 |    0 |    1 |    0 |     0 |    7 |    0 |    1 |    0 |
 |    7 |    0 |     9 |    50 |   17 |    4 |    2 |     8 |    7 |    2 |    0 |    3 |
 |   33 |    1 |     0 |    14 |    0 |    1 |    0 |     1 |    0 |    0 |    3 |    4 |
 |   70 |   34 |    41 |   351 |    9 |  173 |   35 |    49 |   11 |   26 |    7 |   85 |
 |   20 |    1 |     4 |    13 |    3 |    8 |    1 |    13 |    2 |    5 |    3 |    0 |
 |   14 |    5 |    27 |    32 |    3 |    0 |    4 |    25 |    1 |    7 |   42 |    0 |
 |   44 |    3 |    18 |   149 |    5 |   17 |   25 |   107 |    6 |   38 |    7 |    2 |
 |    0 |    1 |     2 |     3 |    0 |    0 |    0 |     0 |    0 |    0 |    0 |    0 |
 |    1 |    1 |     2 |     2 |    1 |    0 |    2 |     1 |    0 |    0 |    0 |    0 |
 |  197 |   23 |   185 |   813 |   93 |   94 |   87 |   361 |   52 |  290 |   65 |   70 |
 |    1 |    0 |     0 |     0 |    0 |    0 |    0 |     0 |    0 |    0 |    0 |    0 |
 |    8 |    0 |     1 |    48 |    1 |    9 |    2 |    35 |    1 |    6 |    1 |    0 |
 |    0 |    0 |    10 |     2 |    3 |    0 |    0 |     3 |    0 |    5 |    2 |    0 |
 | 8350 | 2845 | 11459 | 51802 | 2837 | 4667 | 4222 | 13673 | 4994 | 8228 | 3826 | 7766 |
 |    0 |    0 |     0 |     5 |    1 |    0 |    1 |     0 |    1 |    1 |    0 |    0 |
 |  561 |   46 |   368 |  1106 |  132 |   70 |  164 |   338 |  624 |  175 |  192 |  687 |
 |    1 |    0 |     0 |     1 |    2 |    0 |    0 |     5 |    0 |    0 |    0 |    0 |
 | 1004 |  354 |   371 |  2882 |  148 |  151 |  293 |  1673 |   98 |  655 |   98 |   28 |
 |  177 |   30 |   168 |  1306 |   10 |   76 |   64 |   338 |    5 |   27 |   29 |    6 |
 |    0 |    0 |     0 |     4 |    0 |    0 |    3 |     2 |    0 |    0 |    0 |    0 |
 |    2 |    1 |     2 |    11 |    8 |    2 |    0 |    21 |    0 |    0 |    0 |    1 |
 |   13 |    0 |     2 |    36 |    0 |    4 |    2 |     4 |    1 |   12 |    0 |    0 |
 | 1094 |  970 |    73 |  1129 |   56 |  294 |  414 |   745 |   13 |  301 |   10 |    7 |
 |    3 |    0 |     0 |     2 |    0 |    6 |    0 |     0 |    2 |    5 |    0 |    0 |
 |   50 |    0 |    14 |   125 |    5 |    5 |  114 |    26 |    1 |   50 |    0 |    1 |
 |  192 |    2 |    32 |  1372 |   17 |    6 |    0 |    13 |    0 |   13 |    1 |    0 |

#+BEGIN_SRC R
data <- read.csv("~/code/clojure/twitviz/test_grid.json", header=T)
data <- data[,c(1:ncol(data)-1)]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R
pvals <- data.frame(lang=colnames(data)[2:ncol(data)], pval=sapply(c(2:ncol(data)), function(x) chisq.test(data[,x], data$district)$p.value))
#+END_SRC

#+RESULTS:



** Fisher exact

** 


* Other
** Computing the dataframe

- Read in the tabulated data from the register and compute counts by subsubsubdistrict (a total of 442)
  in each district (a total of 12)

# NOT RUN!!
#+BEGIN_SRC clojure :results silent
(with-open [rdr (clojure.java.io/reader "/Users/quique/data/twitproj/berlin_zensus/dataset3_second.csv")]
  (let [header (first (csv/read-csv rdr))
        dataset (doall (next (csv/read-csv rdr)))
        coerce-fn (fn [[a b c d e f]]
                    [a b (Integer/parseInt c) (Integer/parseInt d)
                     (Integer/parseInt e) (Integer/parseInt f)])]
    (def dataset (vec (cons header (mapv coerce-fn dataset))))))

;; {"District" {"Subdistrict1" {"zh" 123} {"es" 12}}}
(def districts (into #{} (map second (filter #(= 2 (last %)) dataset))))
(def subdistricts (into #{} (map second (filter #(= 8 (last %)) dataset))))
(def langs (into #{} (map first dataset)))

(let [my-dataset (atom {})]
  (doseq [l langs
          district districts
          :let [regex (re-pattern (str "^" (first (clojure.string/split district #" ")) ".*"))]]
    (doseq [row (next dataset)
            :let [subdistrict (second row)
                  v (reduce + (subvec row 2 5))]
            :when (and
                   (not (zero? v))
                   (= 8 (last row))
                   (re-matches regex (second row))
                   (= l (first row)))]
      (swap! my-dataset deep-merge {district {subdistrict {l v}}})))
  (def my-data @my-dataset))
;; (io/frm-save "berlin_by_districts.register" my-data)
#+END_SRC

#+BEGIN_SRC clojure
(spit "berlin_by_districts2.json" (json/write-str my-data :escape-unicode false))
#+END_SRC

#+RESULTS:
: nil

- Sanity check, compute total number of inhabitants
#+BEGIN_SRC clojure
;; (map #(count (vals (second %))) my-data)
#+END_SRC

#+RESULTS:
